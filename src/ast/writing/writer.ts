import { ASTNode, ASTNodeConstructor } from "../ast_node";
import { YulNode } from "../implementation/statement/inline_assembly";
import { SourceFormatter } from "./formatter";

export interface YulNodeWriter {
    write(node: YulNode, writer: YulWriter): string;
}

export type SrcRangeMap = Map<ASTNode, [number, number]>;
export type DescArgs = Array<string | ASTNode | undefined>;
/**
 * The `SrcDesc` is the intermediate description for source that is generated by
 * `ASTNodeWriter`s. It has a tree-like structure, defined by the following grammar:
 *
 * SrcDesc ::= (string | [ASTNode, SrcDesc])*
 *
 * Essentially its a tree of strings, with occasionaly some nodes having an additional ASTNode attached to it,
 * that marks that this subtree corresponds to the text for that ASTNode.
 */
export type SrcDesc = Array<string | [ASTNode, any[]]>;

export interface ASTNodeWriter {
    write(node: ASTNode, writer: ASTWriter): SrcDesc;
}

export class YulWriter {
    mapping: Map<string, YulNodeWriter>;
    formatter: SourceFormatter;

    constructor(mapping: Map<string, YulNodeWriter>, formatter: SourceFormatter) {
        this.mapping = mapping;
        this.formatter = formatter;
    }

    write(node: YulNode): string {
        const writer = this.mapping.get(node.nodeType);

        if (writer) {
            return writer.write(node, this);
        }

        const data = JSON.stringify(node, undefined, 4);

        throw new Error("Unable to find writer for Yul node: " + data);
    }
}

export class ASTWriter {
    mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>;
    formatter: SourceFormatter;
    targetCompilerVersion: string;

    constructor(
        mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>,
        formatter: SourceFormatter,
        targetCompilerVersion: string
    ) {
        this.mapping = mapping;
        this.formatter = formatter;
        this.targetCompilerVersion = targetCompilerVersion;
    }

    write(node: ASTNode, srcM = new Map<ASTNode, [number, number]>()): string {
        const desc = this.desc(node);
        return this.render(desc, srcM);
    }
    private render(desc: SrcDesc, srcM: SrcRangeMap): string {
        let res = "";

        const helper = (cur: SrcDesc): void => {
            for (const el of cur) {
                if (typeof el === "string") {
                    res += el;
                } else {
                    const [nd, ndDesc] = el;
                    const start = res.length;
                    helper(ndDesc);
                    const len = res.length - start;
                    srcM.set(nd, [start, len]);
                }
            }
        };

        helper(desc);

        return res;
    }

    desc(...args: Array<string | ASTNode | undefined | null>): SrcDesc {
        const res: SrcDesc = [];
        for (const arg of args) {
            if (arg === null || arg === undefined) {
                // nothing to do...
            } else if (typeof arg === "string") {
                res.push(arg);
            } else {
                const writer = this.mapping.get(arg.constructor as ASTNodeConstructor<ASTNode>);

                if (!writer) {
                    if (arg instanceof ASTNode) {
                        throw new Error("Unable to find writer for AST arg: " + arg.print());
                    }

                    const data = JSON.stringify(arg, undefined, 4);

                    throw new Error("Expected an instance of ASTNode but got following: " + data);
                }

                res.push([arg, writer.write(arg, this)]);
            }
        }
        return res;
    }
}
