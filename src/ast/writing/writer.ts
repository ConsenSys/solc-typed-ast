import { ASTNode, ASTNodeConstructor } from "../ast_node";
import { YulNode } from "../implementation/statement/inline_assembly";
import { SourceFormatter } from "./formatter";

export interface YulNodeWriter {
    write(node: YulNode, writer: YulWriter): string;
}

export type SrcRangeMap = Map<ASTNode, [number, number]>;
export type DescArgs = Array<string | ASTNode | undefined | null>;
/**
 * The `SrcDesc` is the intermediate description for source that is generated by
 * `ASTNodeWriter`s. It has a tree-like structure, defined by the following grammar:
 *
 * SrcDesc ::= (string | [ASTNode, SrcDesc])*
 *
 * Essentially its a tree of strings, with some ASTNode attached to it at given locations.
 *
 * For example having `[ASTNode#5, <SrcDescX>]` in the tree, indicates that the
 * source generated by <SrcDescX> corresponds precisely to `ASTNode#5` in the
 * source map.
 */
export type SrcDesc = Array<string | [ASTNode, any[]]>;

/**
 * Base class for all ASTNodeWriters. Child classes are responsible for
 * generating a `SrcDesc` for every node.
 */
export abstract class ASTNodeWriter {
    /**
     * Generate a `SrcDesc` for a given node, but without adding the
     * node itself to the tree.
     *
     * @param node - node
     * @param writer - writer
     */
    abstract writeInt(node: ASTNode, writer: ASTWriter): SrcDesc;
    /**
     * Add the node to the descrioption generated by `writeInt`, any additional 'wrappings' and return it. Usually `write` is responsible
     * for adding semicolons and documentation, since these are not generally part of source mappings.
     *
     * For example given this source:
     * `a = 1;`
     *
     * `ExpressionStatement.writeInt` would return the following desc:
     *
     * [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]
     *
     * Then `ExpressionStatement.writeInt` would add in the `ExpressionStatement` node and the semicolon to return:
     *
     * [[ExpressionStatement#4, [[Assignment#3, [[Identifier#1, ["a"]], " = ", [Literal#2, ["1"]] ]]]], ";"]
     *
     * @param node
     * @param writer
     */
    write(node: ASTNode, writer: ASTWriter): SrcDesc {
        return [[node, this.writeInt(node, writer)]];
    }
}

export class YulWriter {
    mapping: Map<string, YulNodeWriter>;
    formatter: SourceFormatter;

    constructor(mapping: Map<string, YulNodeWriter>, formatter: SourceFormatter) {
        this.mapping = mapping;
        this.formatter = formatter;
    }

    write(node: YulNode): string {
        const writer = this.mapping.get(node.nodeType);

        if (writer) {
            return writer.write(node, this);
        }

        const data = JSON.stringify(node, undefined, 4);

        throw new Error("Unable to find writer for Yul node: " + data);
    }
}

export class ASTWriter {
    mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>;
    formatter: SourceFormatter;
    targetCompilerVersion: string;

    constructor(
        mapping: Map<ASTNodeConstructor<ASTNode>, ASTNodeWriter>,
        formatter: SourceFormatter,
        targetCompilerVersion: string
    ) {
        this.mapping = mapping;
        this.formatter = formatter;
        this.targetCompilerVersion = targetCompilerVersion;
    }

    /**
     * Write out the given `node` to a string. If given a source map `srcM`, add a mapping
     * from every child of `node`, to its corrseponding range in the resulting string in `srcM`.
     * @param node node
     * @param srcM source map
     */
    write(node: ASTNode, srcM = new Map<ASTNode, [number, number]>()): string {
        const desc = this.desc(node);
        return this.render(desc, srcM);
    }

    /**
     * Helper function to convert the source description `desc` generated by the `ASTNodeWriter`s into a
     * string, while also populating the given source map `srcM`
     *
     * @param desc
     * @param srcM
     */
    private render(desc: SrcDesc, srcM: SrcRangeMap): string {
        let res = "";

        const helper = (cur: SrcDesc): void => {
            for (const el of cur) {
                if (typeof el === "string") {
                    res += el;
                } else {
                    const [nd, ndDesc] = el;
                    const start = res.length;
                    helper(ndDesc);
                    const len = res.length - start;
                    srcM.set(nd, [start, len]);
                }
            }
        };

        helper(desc);

        return res;
    }

    /**
     * Helper function used by `ASTNodeWriter`s to generate `SrcDesc`s
     * @param args
     */
    desc(...args: DescArgs): SrcDesc {
        const res: SrcDesc = [];
        for (const arg of args) {
            if (arg === null || arg === undefined) {
                // nothing to do...
            } else if (typeof arg === "string") {
                res.push(arg);
            } else {
                const writer = this.mapping.get(arg.constructor as ASTNodeConstructor<ASTNode>);

                if (!writer) {
                    if (arg instanceof ASTNode) {
                        throw new Error("Unable to find writer for AST arg: " + arg.print());
                    }

                    const data = JSON.stringify(arg, undefined, 4);

                    throw new Error("Expected an instance of ASTNode but got following: " + data);
                }

                res.push(...writer.write(arg, this));
            }
        }
        return res;
    }
}
